package com.afklive.streamer;

import com.afklive.streamer.endpoint.StreamController;
import com.afklive.streamer.model.User;
import com.afklive.streamer.model.PlanType;
import com.afklive.streamer.repository.ScheduledVideoRepository;
import com.afklive.streamer.service.*;
import com.afklive.streamer.util.SecurityUtils;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.ResponseEntity;
import org.springframework.mock.web.MockMultipartHttpServletRequest;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.security.Principal;
import java.util.Collections;
import java.util.List;
import java.util.Optional;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

class SecurityVulnerabilityTest {

    @TempDir
    Path tempDir;

    @Test
    void testLogLeak_StreamKeysExposed_Fixed() {
        StreamService streamService = new StreamService();
        String sensitiveKey = "live_12345_secret_key";
        String logLine = "ffmpeg -i input.mp4 -f flv rtmp://a.rtmp.youtube.com/live2/" + sensitiveKey;

        streamService.addLog(logLine);

        List<String> logs = streamService.getLogs();
        assertThat(logs).hasSize(1);
        assertThat(logs.get(0)).doesNotContain(sensitiveKey);
        assertThat(logs.get(0)).contains("[REDACTED]");
    }

    @Test
    void testPathTraversal_DeleteFile_Fixed() throws Exception {
        // Setup Controller with Mocks
        StreamController streamController = new StreamController();
        // Reflection to inject mocks or use a framework?
        // Since we are in a simple test without Spring context, we can use reflection or constructor injection if available.
        // StreamController uses field injection mostly.

        // Let's use Reflection to inject UserFileService
        UserFileService userFileService = mock(UserFileService.class);
        ScheduledVideoRepository videoRepo = mock(ScheduledVideoRepository.class);

        injectField(streamController, "userFileService", userFileService);
        injectField(streamController, "scheduledVideoRepository", videoRepo);
        injectField(streamController, "storageService", mock(FileStorageService.class));
        injectField(streamController, "userService", mock(UserService.class));

        Principal principal = mock(Principal.class);
        when(principal.getName()).thenReturn("attacker");
        // Mock SecurityUtils? It's static.
        // SecurityUtils.getEmail(principal) calls principal.getName() usually if not OAuth2.
        // Wait, SecurityUtils.getEmail checks instance of OAuth2User etc.
        // If I pass a simple Principal, it might return null or handle it.
        // SecurityUtils implementation:
        /*
        public static String getEmail(Principal principal) {
            if (principal instanceof OAuth2User) ...
            if (principal instanceof UserDetails) ...
            if (principal != null) return principal.getName();
        }
        */
        // So principal.getName() should work.

        // Test with malicious filename
        String fileName = "../../target.txt";

        ResponseEntity<?> response = streamController.deleteFile(fileName, principal);

        assertThat(response.getStatusCode().value()).isEqualTo(400); // Bad Request
        assertThat(response.getBody().toString()).contains("Invalid filename");
    }

    @Test
    void testPathTraversal_StartStream_MusicName_Fixed() throws Exception {
        StreamService streamService = new StreamService();
        // Inject mocks
        injectField(streamService, "userFileService", mock(UserFileService.class));
        injectField(streamService, "streamJobRepo", mock(com.afklive.streamer.repository.StreamJobRepository.class));
        injectField(streamService, "userService", mock(UserService.class));
        injectField(streamService, "youTubeService", mock(YouTubeService.class));

        // Mock UserService to return a valid user to avoid NPEs
        UserService userService = (UserService) getField(streamService, "userService");
        User user = new User();
        user.setPlanType(PlanType.FREE);
        when(userService.getOrCreateUser(any())).thenReturn(user);
        when(userService.checkCreditLimit(any())).thenReturn(true);

        com.afklive.streamer.repository.StreamJobRepository jobRepo = (com.afklive.streamer.repository.StreamJobRepository) getField(streamService, "streamJobRepo");
        when(jobRepo.countByUsernameAndIsLiveTrue(any())).thenReturn(0L);

        UserFileService ufs = (UserFileService) getField(streamService, "userFileService");
        when(ufs.getUserUploadDir(any())).thenReturn(tempDir);

        // Create dummy video file
        Files.createFile(tempDir.resolve("stream_video"));

        // Malicious music name
        String musicName = "../../passwd";
        List<String> streamKeys = List.of("key");

        assertThatThrownBy(() ->
            streamService.startStream("user", streamKeys, "video", musicName, "1.0", 1, null, false, "original", 720, null, null, null, false, null, false)
        ).isInstanceOf(IllegalArgumentException.class)
         .hasMessageContaining("Invalid music filename");
    }

    // Helper for reflection
    @Test
    void testSSRF_StartStream() throws Exception {
        StreamService streamService = new StreamService();
        // Inject mocks (same as musicName test)
        injectField(streamService, "userFileService", mock(UserFileService.class));
        injectField(streamService, "streamJobRepo", mock(com.afklive.streamer.repository.StreamJobRepository.class));
        injectField(streamService, "userService", mock(UserService.class));

        UserService userService = (UserService) getField(streamService, "userService");
        User user = new User();
        user.setPlanType(PlanType.FREE);
        when(userService.getOrCreateUser(any())).thenReturn(user);
        when(userService.checkCreditLimit(any())).thenReturn(true);

        com.afklive.streamer.repository.StreamJobRepository jobRepo = (com.afklive.streamer.repository.StreamJobRepository) getField(streamService, "streamJobRepo");
        when(jobRepo.countByUsernameAndIsLiveTrue(any())).thenReturn(0L);

        // Malicious key - Loopback
        List<String> streamKeys = List.of("rtmp://127.0.0.1/live");
        assertThatThrownBy(() ->
            streamService.startStream("user", streamKeys, "video", null, "1.0", 1, null, false, "original", 720, null, null, null, false, null, false)
        ).isInstanceOf(IllegalArgumentException.class)
         .hasMessageContaining("Streaming to local/private network is not allowed");

        // Malicious key - Private 172.16
        List<String> streamKeys2 = List.of("rtmp://172.16.0.5/live");
        assertThatThrownBy(() ->
            streamService.startStream("user", streamKeys2, "video", null, "1.0", 1, null, false, "original", 720, null, null, null, false, null, false)
        ).isInstanceOf(IllegalArgumentException.class)
         .hasMessageContaining("Streaming to local/private network is not allowed");

        // Malicious key - IPv6 Loopback
        List<String> streamKeys3 = List.of("rtmp://[::1]/live");
        assertThatThrownBy(() ->
            streamService.startStream("user", streamKeys3, "video", null, "1.0", 1, null, false, "original", 720, null, null, null, false, null, false)
        ).isInstanceOf(IllegalArgumentException.class)
         .hasMessageContaining("Streaming to local/private network is not allowed");

        // Valid Public IP starting with 172
        List<String> streamKeys4 = List.of("rtmp://172.217.1.1/live"); // Google
        // This should pass the SSRF check (but fail on other things like file not found if we don't mock correctly, or pass if everything else mocks out)
        // Since we didn't create "stream_video", it might fail with IOException: Video not found
        // But if we create it, it should pass.
        // We need to create stream_video for this test method too since we are reusing the tempDir
        if (!Files.exists(tempDir.resolve("stream_video"))) {
            Files.createFile(tempDir.resolve("stream_video"));
        }

        // It will try to start process, which might fail or succeed depending on FFmpeg presence.
        // But we want to ensure it DOES NOT throw "Streaming to local/private network is not allowed".
        try {
            streamService.startStream("user", streamKeys4, "video", null, "1.0", 1, null, false, "original", 720, null, null, null, false, null, false);
        } catch (Exception e) {
             assertThat(e.getMessage()).doesNotContain("Streaming to local/private network is not allowed");
        }
    }

    private void injectField(Object target, String fieldName, Object value) throws Exception {
        java.lang.reflect.Field field = target.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(target, value);
    }

    private Object getField(Object target, String fieldName) throws Exception {
        java.lang.reflect.Field field = target.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        return field.get(target);
    }
}
